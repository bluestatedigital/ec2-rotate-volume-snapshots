#!/usr/bin/env ruby

require 'rubygems'
require 'aws-sdk'
require 'optparse'
require 'retrier'

AWS.start_memoizing

opts = {
  :aws_access_key => ENV["AWS_ACCESS_KEY_ID"],
  :aws_secret_access_key => ENV["AWS_SECRET_ACCESS_KEY"],
  :aws_region => 'us-east-1',
  :pattern => nil,
  :by_tags => nil,
  :dry_run => false,
  :backoff_limit => 0
}

time_periods = {
  :hourly  => { :seconds => 60 * 60, :format => '%Y-%m-%d-%H', :keep => 0 },
  :daily   => { :seconds => 24 * 60 * 60, :format => '%Y-%m-%d', :keep => 0 },
  :weekly  => { :seconds => 7 * 24 * 60 * 60, :format => '%Y-%W', :keep => 0 },
  :monthly => { :seconds => 30 * 24 * 60 * 60, :format => '%Y-%m', :keep => 0 },
  :yearly  => { :seconds => 12 * 30 * 24 * 60 * 60, :format => '%Y', :keep => 0 },
}

OptionParser.new do |o|
  script_name = File.basename($0)
  o.banner = "Usage: #{script_name} [options] <volume_ids>\nUsage: #{script_name} --by-tags <tag=value,...> [other options]"
  o.separator ""

  o.on("--aws-access-key ACCESS_KEY", "AWS Access Key") do |v|
    opts[:aws_access_key] = v
  end

  o.on("--aws-secret-access-key SECRET_KEY", "AWS Secret Access Key") do |v|
    opts[:aws_secret_access_key] = v
  end

  o.on("--aws-region REGION", "AWS Region") do |v|
    opts[:aws_region] = v
  end

  o.on("--pattern STRING", "Snapshots without this string in the description will be ignored") do |v|
    opts[:pattern] = v
  end

  o.on("--by-tags TAG=VALUE,TAG=VALUE", "Instead of rotating specific volumes, rotate over all the snapshots having the intersection of all given TAG=VALUE pairs.") do |v|
    opts[:by_tags] ||= {}
    v.split(',').each do |pair|
      tag, value = pair.split('=', 2)
      if value.nil?
        puts "invalid tag=value format: #{pair}"
        exit 1
      end
      opts[:by_tags][tag] = value
    end
  end

  o.on("--backoff-limit LIMIT", "Backoff and retry when hitting EC2 Request Limit exceptions no more than this many times. Default is 0 (no limit)") do |v|
    opts[:backoff_limit] = v.to_i
  end

  time_periods.keys.sort { |a, b| time_periods[a][:seconds] <=> time_periods[b][:seconds] }.each do |period|
    o.on("--keep-#{period} NUMBER", Integer, "Number of #{period} snapshots to keep") do |v|
      time_periods[period][:keep] = v.to_i
    end
  end

  o.on("--keep-last", "Keep the most recent snapshot, regardless of time-based policy") do |v|
    opts[:keep_last] = true
  end

  o.on("--dry-run", "Shows what would happen without doing anything") do |v|
    opts[:dry_run] = true
  end
end.parse!

if opts[:aws_access_key].nil? || opts[:aws_secret_access_key].nil?
  puts "You must specify your Amazon credentials via --aws-access-key and --aws-secret_access-key"
  exit 1
end

if ARGV.empty? and opts[:by_tags].nil?
  puts "You must provide at least one volume id when not rotating by tags"
  exit 1
end

if opts[:by_tags].nil?
  volume_ids = ARGV

  volume_ids.each do |volume_id|
    if volume_id !~ /^vol-/
      # sanity check
      puts "Invalid volume id: #{volume_id}"
      exit 1
    end
  end
else
  if !ARGV.empty?
    puts "A volume id was supplied when rotating by tags."
    exit 1
  end
  if opts[:by_tags].length == 0
    puts "Rotating by tags but no tags specified? Refusing to rotate all snapshots!"
    exit 1
  end
end

if opts[:backoff_limit] < 0
  puts "Please specify a positive backoff_limit."
  exit 1
end

retrier = Retrier::Backoff.new(opts[:backoff_limit]) do |e|
  # This block should return "true" for any exceptions raised by the retrier
  # that we want to be retried.
  e.kind_of?(AWS::Errors::ClientError) && e.message == 'RequestLimitExceeded'
end

ec2 = retrier.execute do
  global_ec2 = AWS::EC2.new(:access_key_id => opts[:aws_access_key], :secret_access_key => opts[:aws_secret_access_key])
  global_ec2.regions[opts[:aws_region]]
end

def rotate_snapshots(snapshots, time_periods, ec2, retrier, opts = {})
  # poor man's way to get a deep copy of our time_periods definition hash
  periods = Marshal.load(Marshal.dump(time_periods))

  snapshots = snapshots.sort {|a,b| a.started_at <=> b.started_at }
  if opts[:pattern]
    snapshots = snapshots.select do |snapshot|
      if snapshot.description !~ /#{opts[:pattern]}/
        puts "  #{snapshot.start_time '%Y-%m-%d %H:%M:%S'} #{snapshot.id} Skipping snapshot with description #{snapshot.description}"
        false
      else
        true
      end
    end
  end

  snapshot_list = snapshots.map {|snapshot| { :snapshot => snapshot, :created_at => snapshot.start_time } }
  Rotater.rotate_items(snapshot_list, time_periods, opts[:keep_last]) do |item, delete, keep_reason|
    snapshot = item[:snapshot]
    if delete
      puts "  #{snapshot.start_time.strftime '%Y-%m-%d %H:%M:%S'} #{snapshot.id} Deleting"
      retrier.execute { snapshot.delete } unless opts[:dry_run]
    else
      puts "  #{snapshot.start_time.strftime '%Y-%m-%d %H:%M:%S'} #{snapshot.id} Keeping for #{keep_reason}"
    end
  end
end

snapshot_lists_to_rotate = []

if opts[:by_tags]
  snapshot_lists_to_rotate << retrier.execute do
    ec2.snapshots.tagged(opts[:by_tags].keys).tagged_values(opts[:by_tags].values).to_a.select do |snapshot|
      # The filtering above doesn't actually check that the keys and values match,
      # so we do that manually.
      opts[:by_tags].each do |key, value|
        return false if snapshot.tags[key] != value
      end
      true
    end
  end
else
  volume_ids.each do |volume_id|
    snapshot_lists_to_rotate << retrier.execute do
      ec2.snapshots.filter('volume-id', volume_id).to_a
    end
  end
end

snapshot_lists_to_rotate.each do |snapshots| 
  rotate_snapshots(snapshots, time_periods, ec2, opts)
end
